<!DOCTYPE html>
<meta charset="utf-8">
<head>
  	<title>Corren McCoy, CS895, Assignment 7</title> 
	<!--[if IE]><script src="../karate/js/excanvas.js"></script><![endif]-->
	<script src="http://d3js.org/d3.v3.js"></script>
<style>
.link {
  fill: none;
  stroke: #666;
  stroke-width: 1.5px;
}

circle {
  fill: #ccc;
  stroke: #fff;
  stroke-width: 1.5px;
}

text {
  fill: #000;
  font: 10px sans-serif;
  pointer-events: none;
}
.node.fixed {
  fill: #f00;
}
rect {
  fill: aliceblue;
  stroke: #000;
  stroke-width: 3px;
}
.faction {
  fill: green;
  stroke: #000;
  stroke-width: 3px;
}

</style>
<body>
<div id="option">
<button>Toggle</button>
</div>
<script>
// Sample D3: http://www.d3noob.org/2013/03/d3js-force-directed-graph-example-basic.html

// Get the data generated by the Python conversion function
d3.csv("data/karateLinks.csv", function(error, links) {

// empty container for nodes
var nodes = [];

// Compute the distinct nodes from the links.
// This block of code looks through all of out data from our csv file and for 
// each link adds it as a node if it hasn't seen it before. 
// Shorthand: “*If* `link.source` *does not equal any of the `nodes` 
// values then create a new element in 
// the `nodes` object with the name of the `link.source` value being considered.*”. 
// Then the block of code goes on to test the `link.target` value in the s
// ame way. Then the `faction`  variable is converted to a number from 
// a string if necessary (`link.faction = +link.faction;`).

links.forEach(function(link) {
	// Use the node's faction setting of 1 or 2 as an index to select the color.
	// Note: array indexing is zero based
	var factionColor = ["red", "#17becf", "ff7f0e"];
	
    link.source = nodes[link.source] || 
        (nodes[link.source] = {	name: link.source, 
								faction: link.sfaction, 
								color: factionColor[link.sfaction]});
    link.target = nodes[link.target] || 
        (nodes[link.target] = {	name: link.target, 
								faction: link.tfaction, 
								color: factionColor[link.tfaction]});
    link.faction = +link.faction;
});

// sets the size of our svg area that we'll be using.
var width = 960,
    height = 720;

// .nodes(d3.values(nodes)) sets our layout to the array of `nodes` 
// as returned by the function `d3.values` 
// (https://github.com/mbostock/d3/wiki/Arrays#wiki-d3_values). 
// Put simply, it sets the nodes to the `nodes` 
// we have previously set in our object.
// .links(links) does for links what `.nodes` did for nodes.
var force = d3.layout.force()
    .nodes(d3.values(nodes))
    .links(links)
    .size([width, height])
    .linkDistance(200)
    .charge(-300)
    .gravity(0.06)
    .on("tick", tick)
    .start();
	
// Sticky mode so node doesn't move after re-positioning
var drag = force.drag()
    .on("dragstart", dragstart);

var svg = d3.select("body").append("svg")
    .attr("width", width)
    .attr("height", height)

// boundary of screen canvas
svg.append("svg:rect")
    .attr("width", width)
    .attr("height", height)
	.attr("class","rect");

// add the links and the arrows
var link = svg.selectAll(".link")
    .data(force.links())
  .enter().append("line")
    .attr("class", "link");


// define the nodes
var node = svg.selectAll(".node")
    .data(force.nodes())
  .enter().append("g")
    .attr("class", "node")
    .call(force.drag);

// add the nodes
node.append("circle")
    .attr("r", 25);

// add the text for each node
node.append("text")
    .attr("dx", -18)
    .attr("dy", ".35em")
    .text(function(d) { return d.name; });

	
d3.select('button').on('click', function(d) {
	// Make the nodes change color to show the split
	d3.selectAll("circle")
		.style("fill", function(d) {return  d.color;}) ;
})

// add the link lines
function tick() {
  link
      .attr("x1", function(d) { return d.source.x; })
      .attr("y1", function(d) { return d.source.y; })
      .attr("x2", function(d) { return d.target.x; })
      .attr("y2", function(d) { return d.target.y; });
 
	node
      .attr("transform", function(d) { return "translate(" + d.x + "," + d.y + ")"; });
}

// keep nodes in position after dragging
function dragstart(d) {
  d.fixed = true;
  d3.select(this).classed("fixed", true);
} // dragstart


}); // end go d3.csv

</script>

</body>
</html>
